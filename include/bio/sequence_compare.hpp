/***
 *  $Id$
 **
 *  File: sequence_compare.hpp
 *  Created: May 03, 2012
 *
 *  Author: Jaroslaw Zola <jaroslaw.zola@gmail.com>
 *  Copyright (c) 2012 Jaroslaw Zola
 *  Distributed under the Boost Software License.
 *
 *  This code has been derived from the bio package by Jaroslaw Zola.
 *
 *  Boost Software License - Version 1.0 - August 17th, 2003
 *
 *  Permission is hereby granted, free of charge, to any person or organization
 *  obtaining a copy of the software and accompanying documentation covered by
 *  this license (the "Software") to use, reproduce, display, distribute,
 *  execute, and transmit the Software, and to prepare derivative works of the
 *  Software, and to permit third-parties to whom the Software is furnished to
 *  do so, all subject to the following:
 *
 *  The copyright notices in the Software and this entire statement, including
 *  the above license grant, this restriction and the following disclaimer,
 *  must be included in all copies of the Software, in whole or in part, and
 *  all derivative works of the Software, unless such copies or derivative
 *  works are solely in the form of machine-executable object code generated by
 *  a source language processor.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 *  SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 *  FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 *  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 *  DEALINGS IN THE SOFTWARE.
 */

#ifndef SEQUENCE_COMPARE_HPP
#define SEQUENCE_COMPARE_HPP

#include <algorithm>
#include <cstring>
#include <string>
#include <vector>


namespace bio {

  class global_alignment {
  public:
      explicit global_alignment(int m = 0, int mm = 0, int g = 0, int h = 0)
	  : m_(m), mm_(mm), g_(g), h_(h) { }

      unsigned int operator()(const std::string& s0, const std::string& s1) {
	  unsigned int n = s0.size() + 1;
	  unsigned int m = s1.size() + 1;

	  // S(i, j) = max{ I(i, j), D(i, j), S(i - 1, j - 1) + d(i,j) }
	  // D(i, j) = max{ D(i, j - 1), S(i, j - 1) + g } + h
	  // I(i, j) = max{ I(i - 1, j), S(i - 1, j) + g } + h

	  S_.resize(m, 0);
	  I_.resize(m, 0);

	  track_.resize(n * m);

	  for (unsigned int j = 1; j < m; ++j) {
	      track_[j] = LEFT;
	      S_[j] = I_[j] = g_ + j * h_;
	  }

	  unsigned int pos = 0;
	  unsigned int Sij = 0;

	  for (unsigned int i = 1; i < n; ++i) {
	      int Si = g_ + i * h_;
	      int Di = g_ + i * h_;

	      pos = i * m;
	      track_[pos] = TOP;

	      for (unsigned int j = 1; j < m; ++j) {
		  pos++;

		  Di = std::max(Di, Si + g_) + h_;
		  I_[j] = std::max(I_[j], S_[j] + g_) + h_;

		  int d = (s0[i - 1] == s1[j - 1]) ? m_ : mm_;

		  Si = Sij + d;

		  if (Di < I_[j]) {
		      if (Si < I_[j]) {
			  // max in I_[j]
			  Si = I_[j];
			  track_[pos] = TOP;
		      } else {
			  // max in Si
			  track_[pos] = DIAG;
		      }
		  } else {
		      if (Si < Di) {
			  // max in Di
			  Si = Di;
			  track_[pos] = LEFT;
		      } else {
			  // max in Si
			  track_[pos] = DIAG;
		      }
		  } // if

		  Sij = S_[j];
		  S_[j] = Si;

	      } // for j

	      Sij = g_ + i * h_;
	  } // for i

	  // backtrack
	  unsigned int i = n - 1;
	  unsigned int j = m - 1;

	  unsigned int match = 0;
	  unsigned int length = 0;

	  while ((i > 0) || (j > 0)) {
	      switch (track_[i * m + j]) {
		case TOP:
		    --i;
		    break;

		case LEFT:
		    --j;
		    break;

		case DIAG:
		    --i;
		    --j;
		    if (s0[i] == s1[j]) match++;
		    break;
	      } // switch
	      length++;
	  } // while

	  return (100 * match) / length;
      } // operator()


  private:
      enum { TOP, LEFT, DIAG };

      std::vector<unsigned char> track_;

      std::vector<int> S_;
      std::vector<int> I_;

      int m_;
      int mm_;

      int g_;
      int h_;

  }; // class global_alignment


  class dna_jaccard_index {
  public:
      explicit dna_jaccard_index(unsigned int k = 0, unsigned int e = 0) : k_(k), e_(e) {
	  std::memset(digit_, 0, 256);
	  digit_['c'] = digit_['C'] = 1;
	  digit_['g'] = digit_['G'] = 2;
	  digit_['t'] = digit_['T'] = 3;
	  digit_['u'] = digit_['U'] = 3;
      } // dna_jaccard_index

      unsigned int operator()(const std::string& s0, const std::string& s1) {
	  if (e_ == 0) {
	      prv_create_index__(s0, p0_);
	      prv_create_index__(s1, p1_);
	  } else {
	      prv_create_spaced_index__(s0, p0_);
	      prv_create_spaced_index__(s1, p1_);
	  }

	  std::sort(p0_.begin(), p0_.end());
	  std::sort(p1_.begin(), p1_.end());

	  return prv_count_common__();
      } // operator()

      unsigned int operator()(const std::string& s1) {
	  if (e_ == 0) prv_create_index__(s1, p1_);
	  else prv_create_spaced_index__(s1, p1_);
	  std::sort(p1_.begin(), p1_.end());
	  return prv_count_common__();
      } // operator()


  private:
      char digit_[256];

      void prv_create_index__(const std::string& s, std::vector<unsigned long long int>& p) {
	  unsigned int l = s.size();
	  unsigned int end = l - k_ + 1;

	  p.resize(end);

	  // first kmer
	  unsigned long long int v = digit_[s[k_ - 1]];
	  for (unsigned int i = 0; i < k_ - 1; ++i) {
	      v += digit_[s[i]] * (1UL << ((k_ - i - 1) << 1));
	  }

	  p[0] = v;

	  // and then all other
	  unsigned long long int b = 1UL << ((k_ - 1) << 1);

	  for (unsigned int i = 1; i < end; ++i) {
	      v = (v - b * digit_[s[i - 1]]) * 4 + digit_[s[i + k_ - 1]];
	      p[i] = v;
	  }
      } // prv_create_index__

      void prv_create_spaced_index__(const std::string& s, std::vector<unsigned long long int>& p) {
	  unsigned int l = s.size();
	  unsigned int end = l - 2 * k_ - e_ + 1;

	  p.resize(end);

	  unsigned long long int v0 = digit_[s[k_ - 1]];
	  unsigned long long int v1 = digit_[s[2 * k_ + e_ - 1]];

	  for (unsigned int i = 0; i < k_ - 1; ++i) {
	      v0 += digit_[s[i]] * (1UL << ((k_ - i - 1) << 1));
	      v1 += digit_[s[k_ + e_ + i]] * (1UL << ((k_ - i - 1) << 1));
	  }

	  p[0] = (v0 << (k_ << 1)) + v1;

	  unsigned long long int b = 1UL << ((k_ - 1) << 1);

	  for (unsigned int i = 1; i < end; ++i) {
	      v0 = (v0 - b * digit_[s[i - 1]]) * 4 + digit_[s[i + k_ - 1]];
	      v1 = (v1 - b * digit_[s[k_ + e_ + i - 1]]) * 4 + digit_[s[2 * k_ + e_ + i - 1]];
	      p[i] = (v0 << (k_ << 1)) + v1;
	  }
      } // prv_create_spaced_index__

      unsigned int prv_count_common__() {
	  unsigned int i0 = 0;
	  unsigned int l0 = p0_.size();

	  unsigned int i1 = 0;
	  unsigned int l1 = p1_.size();

	  unsigned int S = 0;

	  while ((i0 < l0) && (i1 < l1)) {
	      if (p0_[i0] < p1_[i1]) ++i0;
	      else if (p1_[i1] < p0_[i0]) ++i1;
	      else {
		  ++S;
		  ++i0;
		  ++i1;
	      }
	  } // while

	  return (100 * S) / std::min(l0, l1);
      } // prv_count_common__

      unsigned int k_;
      unsigned int e_;

      std::vector<unsigned long long int> p0_;
      std::vector<unsigned long long int> p1_;

  }; // class dna_jaccard_index

} // namespace bio

#endif // SEQUENCE_COMPARE_HPP
